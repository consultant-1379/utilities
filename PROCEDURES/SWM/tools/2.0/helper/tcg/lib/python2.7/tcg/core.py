#!/usr/bin/python
import os
import shutil
import stat
import errno
import logging
import AMFModelGenerator
import CgtConstants
import CampaignGenerator
import AMFModel
import ImmHelper
import Utils
from SystemModels import SystemModels, ModelContextData
from tcg.utils.logger_tcg import tcg_error
from tcg.csm_units.role import Role
from tcg.csm_units.system import ComputeResource



"""
The tcg.core module provides an object that serves as OO wrapper, so that it
can be handled from the bin/tcg code.
"""
class TCG(object):
    def __init__(self, delivery_package_dirs,
                 model_fragments,
                 target_directory,
                 script_dir,
                 config_base,
                 online_adapter,
                 plugins_base_dir=None):
        """
        PRE: instantiation argument values have valid content.

        The responsibility of validating the arguments used for the
        constructions of a TCG() instance, is left to the caller, this is:
        the bin/tcg script or tcg entry point.
        """
        self._base_csm_model = None
        self._target_csm_model = None
        self.__discard_system_model_static_instances()

        # Find the models in delivery_package_dirs and add to the set the
        # received model_fragments
        self._model_files = find_model_files(delivery_package_dirs)
        self._model_files.update(model_fragments)

        # Finde the bundles in delivery_package_dirs
        self._sw_bundles = find_bundle_list(delivery_package_dirs)

        # Save the delivery package directories
        self._delivery_package_dirs = delivery_package_dirs

        # Setup the target directory sub directories structure
        self._target_directory = os.path.join(target_directory, "target-config")
        self._config_base_target_directory = os.path.join(self._target_directory, "config-base")
        self._target_SDP_dir = os.path.join(self._target_directory, "campaign-bundles")
        self.__cleanup_target_directory()

        # On installations, the self._config_base will be None.
        if is_installation_use_case(config_base):
            self._config_base = None
        else:
            self._config_base = config_base

        self._online_adapter = online_adapter

        # Save the path where the tcg script lives to instantiate the provided plugins
        self._script_dir = script_dir

        self._immdump_file = self._online_adapter.get_immdump_filename()
        self._hostname_amfnode_map = self._online_adapter.get_hostname_to_amfnode()

        # By default the plugins will be loaded from where the CSM model lives
        # on, however the user (CMW) can change this behavior of TCG by
        # providing a new base path for the plugins.
        self._plugins_base_dir = plugins_base_dir

    def __discard_system_model_static_instances(self):
        # A workaround to make FT work with these static variable
        SystemModels.targetCSMModel = None
        SystemModels.baseCSMModel = None

    def __cleanup_target_directory(self):
        # make sure self._target_directory does not exist by trying to remove
        # if it exists.
        try:
            shutil.rmtree(self._target_directory)
        except OSError as e:
            if e.errno is not errno.ENOENT:
                tcg_error("Failed to cleanup directory %s: %s" % (self._target_directory, str(e)))

    def __invoke_campaign_generator(self, generateOnlyImm=False,
                                    generateInstantiationCamp=False):
        """
        Returns the tuple that is generated by the CampaignGenerator after
        calling its istatic method generateCampaign.
        This tupple is composed of a list of campaings, and list of used
        software bundles: (campaignList, usedBundleSDPs)
        """
        # Generate CSM Unit instances from all the csm yaml model files.
        # Note that all the yaml files stored in modelFiles are converted to
        # dictionaries using PyYaml and stored in "yamlFiles" list
        if self._plugins_base_dir and not self._is_valid_plugin_dir(self._plugins_base_dir):
            tcg_error('Invalid plugin base directory: "%s"' % self._plugins_base_dir)

        model_context = ModelContextData(self._hostname_amfnode_map, 
                                         self._plugins_base_dir)
        base_model_context = ModelContextData(self._hostname_amfnode_map)

        if self._config_base:
            self.set_base_model(self._config_base, base_model_context)
        self.set_target_model(self._model_files, model_context)

        if self._config_base:
            self.finalize_base_model()
        self.finalize_target_model()

        siteConfiguration = self.generate_site_configuration()

        # Get the CSM Migration information
        migration_info = {}
        if not generateInstantiationCamp:
            migration_info = generateMigrationInfo(SystemModels.targetCSMModel)

        # Instantiate AMFModelGenerator with the base csm model
        baseAmfModelGenerator = AMFModelGenerator.AMFModelGenerator()
        if SystemModels.baseCSMModel:
            baseAmfModelGenerator.generateFromCSM(SystemModels.baseCSMModel, self._online_adapter)
        # Instantiate AMFModelGenerator with the target csm model
        amfModelGenerator = AMFModelGenerator.AMFModelGenerator()
        amfModelGenerator.generateFromCSM(SystemModels.targetCSMModel, self._online_adapter)

        # amfModelGenerator.amfModel.writeXML("targetAmfModel.xml")

        # Call the CampaignGenerator and return a tuple
        c, s = CampaignGenerator.generateCampaign(self._config_base,
                                                  model_context,
                                                  self._online_adapter,
                                                  self._immdump_file,
                                                  baseAmfModelGenerator.amfModel,
                                                  amfModelGenerator.amfModel,
                                                  siteConfiguration,
                                                  self._sw_bundles,
                                                  self._config_base_target_directory,
                                                  self._target_SDP_dir,
                                                  self._script_dir,
                                                  self._delivery_package_dirs,
                                                  migration_info,
                                                  generateOnlyImm,
                                                  generateInstantiationCamp)
        return (c, s)

    def set_target_model(self, model_files, model_context):
        SystemModels.setTargetCSMModel(model_files, model_context, self._online_adapter)
        self._target_csm_model = SystemModels.targetCSMModel

    def finalize_target_model(self):
        SystemModels.finalizeTargetCSMModel(self._online_adapter)

    def set_base_model(self, config_base_path, model_context):
        base_model_file = os.path.join(config_base_path, CgtConstants.CDFCGT_CONFIG_BASE_CSM_PART, CgtConstants.CDFCGT_CONFIG_BASE_CSM_MODEL_FILENAME)
    
        if not os.path.exists(base_model_file):
            tcg_error('No config base under the given configbase path.')
    
        logging.debug("Importing base CSM model from: " +  base_model_file)
        try:
            SystemModels.setBaseCSMModel([base_model_file], model_context, self._online_adapter)
        except Exception as e:
            tcg_error("error while parsing base CSM model: " + str(e))
    
        self._base_csm_model = SystemModels.baseCSMModel
    
        logging.debug("set_base_model succeeded" + config_base_path)

    def finalize_base_model(self):
        SystemModels.finalizeBaseCSMModel(self._online_adapter)
    
    def _is_valid_plugin_dir(self, directory):
        return os.path.isdir(directory) and os.path.isabs(directory)

    def generateCampaign(self, enable_test_mode=False):
        """ do the actions to generate a regular campaign """
        self._generate_campaign(enable_test_mode=enable_test_mode)

    def generateInstantiationCampaign(self):
        """ Do the actions to generate an instantiation campaign.
            This special type of campaign, does not contain any reference to
            the sw bundles nor amf bundles.
        """
        self._generate_campaign(instantiation=True)

    def generateImm(self):
        """ just generate the model """
        _, _ = self.__invoke_campaign_generator(generateOnlyImm=True)

    def _generate_campaign(self, instantiation=False, enable_test_mode=False):
        campaign_list, used_sw_bundles = self.__invoke_campaign_generator(generateInstantiationCamp=instantiation)

        Utils.mkdir_safe(self._config_base_target_directory)

        self._create_bundle_mapping_file(used_sw_bundles)

        if self._model_files:
            SystemModels.targetCSMModel.write_domain_mapping_file(os.path.join(self._target_directory,
                                                                  "domain-software-mapping.xml"), self._online_adapter)
            # generate merged csm yaml file
            SystemModels.targetCSMModel.write_csm_config_base(self._config_base_target_directory)

        if enable_test_mode:
            self._generate_test_mode_files_for_troubleshooting(campaign_list, used_sw_bundles)

    def _create_bundle_mapping_file(self, used_sw_bundles):
        with open(os.path.join(self._target_directory, "bundle-mapping"), "a") as bundle_map_file:
            for (sdp_file_name, sdp) in used_sw_bundles:
                bundle_map_file.write(sdp + " " + sdp_file_name + "\n")

            external_sw_bundles = SystemModels.targetCSMModel.getExternalSDPs()
            for (_, sdp_file_name, sdp) in external_sw_bundles:
                bundle_map_file.write(sdp + " " + sdp_file_name + "\n")

    def _generate_test_mode_files_for_troubleshooting(self, campaign_list, used_sw_bundles):
        generateInstallScript(self._target_directory, "install.sh", campaign_list)

        for (sdp_file_name, sdp) in used_sw_bundles:
            sdp_path = None
            for dp_dir in self._delivery_package_dirs:
                file_path = os.path.join(dp_dir, sdp_file_name)
                if os.path.exists(file_path) and os.path.isfile(file_path):
                    sdp_path = file_path
                    break
            if not sdp_path:
                tcg_error("Couldn't find sdp %s in any of the delivery packages" % sdp)

            shutil.copy2(sdp_path, os.path.join(self._target_SDP_dir, sdp_file_name))

    def generate_site_configuration(self):
        '''
        Generates a site configuration information and takes into account the
        predefined roles if any.
        '''
        site_configuration = self._create_site_configuration(self._target_csm_model.system,
                                                                  self._target_csm_model.roles)

        predefined_roles = map(lambda r: r.getUid(), 
                               filter(Role.isExternal, 
                                      self._target_csm_model.roles))

        if not self._online_adapter.is_offline_instantiation() and predefined_roles:
            self._recalculate_compute_resources(predefined_roles)
    
        self._add_system_info_into_site_configuration(site_configuration)
    
        return site_configuration
    
    def _create_site_configuration(self, system, roles):
        '''
        Generate Site Configuration information from the roles and system CSM Units
        siteConfiguration is a Python dictionary containing the roles and system
        CSM unit instances created
    
        siteConfiguration = {CgtConstants.ROLES_TAG: SystemModels.targetCSMModel.system.getRoles(), 
                             CgtConstants.SYSTEM_TAG : SystemModels.targetCSMModel.system}
        '''
        site_configuration = {CgtConstants.ROLES_TAG: [],
                              CgtConstants.SYSTEM_TAG: system}
        site_configuration[CgtConstants.ROLES_TAG].extend( self._target_csm_model.roles )
        return site_configuration
    
    def _recalculate_compute_resources(self, predefined_roles):
        if not self._online_adapter.get_immdump_filename():
            tcg_error("Role_external has been set, immdump is required")

        compute_resources = self._get_compute_resources_from_input_model()
        csm_defined_nodes = filter(lambda cr: cr.getRole() not in predefined_roles,
                                   compute_resources)

        imm_roles, compute_resources = self._get_roles_and_nodes_from_immdump(predefined_roles)
        compute_resources.extend( csm_defined_nodes )

        if not self._have_the_same_roles(predefined_roles, imm_roles):
            tcg_error("Role(s) exist in imm don't exist in base model: PREDEFINED({predefined}) PRESENT_IMM({imm})".format(predefined=predefined_roles, imm=imm_roles))

        self._target_csm_model.system.setComputeResources(compute_resources)
        if (self._base_csm_model is not None):
            self._base_csm_model.system.setComputeResources(compute_resources)

    def _get_compute_resources_from_input_model(self):
        compute_resources = self._target_csm_model.system.getComputeResources()
        if (self._base_csm_model is not None):
            compute_resources = self._base_csm_model.system.getComputeResources()
        return compute_resources

    def _add_system_info_into_site_configuration(self, site_configuration):
        if (self._base_csm_model is not None):
            logging.debug("setting SYSTEM_COMPUTE_RESOURCES_TAG from the base model")
            site_configuration[CgtConstants.SYSTEM_COMPUTE_RESOURCES_TAG] = self._base_csm_model.system.getComputeResources()
        else:
            logging.debug("setting SYSTEM_COMPUTE_RESOURCES_TAG from the target model")
            site_configuration[CgtConstants.SYSTEM_COMPUTE_RESOURCES_TAG] = self._target_csm_model.system.getComputeResources()
    
    def _get_roles_and_nodes_from_immdump(self, predefined_roles):
        roles = []
        nodes = []

        for node_group in self._extract_available_amf_node_groups_from_imm_dump_that_are_in_the_predefined_roles(predefined_roles):
            roles.append( node_group.getName() )
            nodes.extend( self._get_compute_resources_from_amf_node_group(node_group) )

        return roles, nodes

    def _extract_available_amf_node_groups_from_imm_dump_that_are_in_the_predefined_roles(self, predefined_roles):
        dumped_amf_model = self._parse_imm_dump_file(self._online_adapter.get_immdump_filename())
        return filter(lambda ng: ng.getName() in predefined_roles,
                      dumped_amf_model.getObjects(AMFModel.SaAmfNodeGroup).values())

    def _get_compute_resources_from_amf_node_group(self, node_group_object):
        compute_resources = []
        for node_dn in node_group_object.getsaAmfNGNodeList():
            compute_resource = ComputeResource()

            node_name = ImmHelper.getName(node_dn)
            compute_resource.set(node_name, node_group_object.getName())

            compute_resources.append(compute_resource)
        return compute_resources

    def _have_the_same_roles(self, roles1, roles2):
        difference = set(roles1) - set(roles2)
        return len(difference) == 0
    
    def _parse_imm_dump_file(self, immdump_file):
        logging.debug("Parsing imm dump file: %s", immdump_file)
        amf_model = AMFModel.AMFModel()
        try:
            amf_model.parseXML(immdump_file)
        except Exception as e:
            tcg_error("error while parsing base imm dump: " + str(e))
        return amf_model



#########################################

def find_model_files(dir_list):
    """
    Find all the yaml model files in the list of given directories.

    As a result, the function will return a "model_files" set with the yaml
    files' (fragments) absolute paths
    """
    model_files = __find_files_by_extension(dir_list, [".yml", ".yaml"])

    return model_files


def find_bundle_list(dir_list):
    """
    Find all the software bundles files in dir_list.
    """
    sw_bundles = __find_files_by_extension(dir_list, [".sdp", ".rpm"])

    return sw_bundles


def __find_files_by_extension(dir_list, extensions_list):
    files = set()

    for myDir in dir_list:
        for f in os.listdir(myDir):
            if os.path.isfile(os.path.join(myDir, f)):
                (_, ext) = os.path.splitext(f)
                if ext in extensions_list:
                    files.add(os.path.join(myDir, f))

    return files

def validateDuplicate(baseList, newList, tag):
    newElemTags = []
    for newElem in newList:
        if newElem[tag] in newElemTags:
            tcg_error("ERROR: the following element is defined more than once in the same file: %s: %s" % (tag, newElem[tag]))
        newElemTags.append(newElem[tag])
        for baseElem in baseList:
            if baseElem[tag] == newElem[tag]:
                tcg_error("ERROR: the following element is defined more than once over different files: %s: %s" % (tag, baseElem[tag]))


def is_installation_use_case(config_base):
    """
    If the <config_base>/CSM directory does not exist, we can consider TCG
    has been invoked during an installation, otherwise is an upgrade.
    """
    is_installation = False
    if config_base:
        csm_dir = os.path.join(config_base, "CSM")
        is_installation = not (os.path.exists(csm_dir) and os.path.isdir(csm_dir))
    return is_installation


def generateInstallScript(targetDir, scriptName, campaingList):
    install_script = """#!/bin/sh

import_sdp()
{
   echo "Importing SDP $1"
   SDPNAME=$1
   SDPNAME=${SDPNAME%%\.sdp}
   SDPNAME=`basename $SDPNAME`
   if cmw-repository-list  | awk ' {  print $1 } ' | grep -q $SDPNAME;
   then
       echo "SDP $SDPNAME is already imported"
   elif cmw-repository-list --campaign | awk ' {  print $1 } ' | grep -q $SDPNAME;
   then
       echo "SDP $SDPNAME is already imported"
   else
       cmw-sdp-import $1 || exit 1
   fi
}

install_campaign()
{
    echo "Installing $1"
    STATUS=`cmw-campaign-status $1`
    if [ "$STATUS" == "$1=COMMITTED" ];
    then
        echo -e "\\tCampaign $1 already COMMITTED"
        return
    fi

    if [ "$STATUS" == "$1=COMPLETED" ];
    then
        echo -e "\\tCampaign $1 already COMPLETED, committing it"
        cmw-campaign-commit $1
        sleep 10
        return
    fi

    if [ "$STATUS" == "$1=INITIAL" ];
    then
          echo -e "\\tStarting campaign $1"
        cmw-campaign-start $1
    fi

   STATUS=`cmw-campaign-status $1`
   echo -e "\\tStatus is $STATUS"
   while [ "$STATUS" != "$1=COMPLETED" ];
   do
        TIMESTAMP=`date`
          echo -e "\\t $TIMESTAMP Waiting for campaign: $STATUS"
          sleep 2
        STATUS=`cmw-campaign-status $1`
        FAILEDSTATUS=`cmw-campaign-status $1 | grep FAILED`
        if [ "$FAILEDSTATUS" != "" ];
        then
            echo "Campaign install failed, for more details check /var/log/messages"
            exit 1
        fi
   done
   sleep 30
   echo -e "\\t Campaign install done, committing"
   cmw-campaign-commit $1
   sleep 10
}

DIR=`dirname $0`

SDP_DIR=$DIR/campaign-bundles

SDPS=`ls $SDP_DIR/*.sdp`
for sdp in $SDPS; do
   import_sdp $sdp
done

"""
    for campaign in campaingList:
        install_script += "install_campaign %s\n" % campaign

    # open the file and dump the install_script text into it
    fileName = os.path.join(targetDir, scriptName)
    f = open(fileName, "w")
    f.write(install_script)
    f.close()

    # Give execution permission to the script
    st = os.stat(fileName)
    os.chmod(fileName, st.st_mode | stat.S_IEXEC)


def generateMigrationInfo(target_csm_model):
    info = {}
    for comp in target_csm_model.components:
        if comp.get_supersedes():
            info[comp.uid] = comp.get_supersedes()
    return info
